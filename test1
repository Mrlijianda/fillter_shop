import time
from queue import Queue

import win32com.client
from UI.ui_main_window import Ui_mainwindow
from PyQt5.Qt import *

class GlobalSignals(QObject):
    data1_ui_signal = pyqtSignal(str)  # 1台|(UI界面)开奖数据|信号
    data1_signal = pyqtSignal(str)  # 1台|(赢-和)开奖数据|信号
    data1_fail_signal = pyqtSignal(str)  # 1台|(输)开奖数据|信号
    data1_stop_signal = pyqtSignal(str)  # 1台|休盘|信号
    data1_check_signal = pyqtSignal(str)  # 1台|检查结果|信号
    data1_heart_signal = pyqtSignal(int)  # 1台|心跳|信号

    bet1_log_signal = pyqtSignal(str)  # 自动下注1|日志|信号

# 7个台子对应的监控线程x
class Worker1(QThread, QWidget):
    global_signals = GlobalSignals()

    def __init__(self, dm):
        super().__init__()
        self.dm = dm
        self.data1_heart_count = 0
        self.plan_dic = {
            '等待方案1': '闲闲闲闲庄闲',
            '等待方案2': '闲闲闲庄庄',
            '等待方案3': '闲闲闲闲庄庄',
            '等待方案4': '闲闲庄闲闲闲',
            '等待方案5': '闲闲闲庄闲',
            '等待方案6': '闲闲庄庄庄闲',
            '等待方案7': '闲闲庄庄闲',
            '等待方案8': '闲闲闲闲庄庄闲',
            '等待方案9': '闲闲闲庄庄庄庄',
            '等待方案10': '闲闲闲庄闲闲庄'
        }
        self.one_result_str = ''  # 1台|开奖结果
        self.one_result_str_last = ''  # 1台|临时开奖结果
        self.betting1Thread = QThread()  # 实例化bet1多线程

    def run(self):
        try:
            # 开始程序
            self.bet1 = Betting1(self.global_signals.data1_signal, self.global_signals.data1_fail_signal)  # 实例化bet1类
            print('实例化bet1类')
            while True:
                time.sleep(1)
                # ------------------------执行1号台-----------------------------
                self.one_result_str_last = self.one_result_str  # 临时变量
                self.left_one_table()  # 获取开奖数据
                print(
                    f'当前盘面开奖数量----------------------------------------------------->{len(self.one_result_str)}')
                print('1号台,等待开奖.......')
                if self.one_result_str != self.one_result_str_last:  # 判断是否开奖
                    self.global_signals.data1_ui_signal.emit(self.one_result_str)  # 给UI发送开奖数据
                    if not self.bet1.fail_state:  # 如果下注1当前状态-->赢|和
                        print('60行代码处，发送了一次开奖信号(赢-和)')
                        self.global_signals.data1_signal.emit(self.one_result_str)  # 方案是否匹配都先发送一次开奖信号
                        time.sleep(0.1)  # 开奖信号发送等待1秒
                    else:  # 如果下注1当前状态-->输
                        print('65行代码处，发送了一次开奖信号(输)')
                        self.global_signals.data1_fail_signal.emit(self.one_result_str)  # 方案是否匹配都先发送一次开奖信号
                    check_result = self.check_result(self.one_result_str)  # 结果与等待方案比对
                    # print('1号台,比对方案结束...')
                    if check_result != '暂无匹配方案':
                        pass
                        # 保存有效结果
                        # print('1台已出现匹配方案--->', check_result, '保存中.....')
                        # current_time = datetime.datetime.now()
                        # with open('resource/1台_有效结果.txt', 'a', encoding='utf-8') as f:
                        #     f.write(str(current_time) + '----> 1台 ----> ' + check_result + '\n')
                        # print('1台已出现匹配方案--->', check_result, '保存完毕')
                    else:
                        self.global_signals.data1_check_signal.emit(check_result)  # 暂无匹配方案,发送检查结果|信号
        except Exception as e:
            print('Worker1|run--->', e)

    # 左1桌
    def left_one_table(self):
        try:
            # 心跳+1
            self.data1_heart_count += 1
            # 判断开局状态
            XP_PIC = self.dm.FindPicE(592, 126, 620, 159, "resource_pic/洗牌.bmp", "080808", 0.4, 0)
            list_xp = XP_PIC.split("|")
            # 洗牌中
            if int(list_xp[1]) > 0:
                stop_str = '洗牌中....等待游戏开始......'
                self.global_signals.data1_stop_signal.emit(stop_str)
            # 游戏开始
            else:
                # 延迟0.5秒
                time.sleep(0.5)
                self.one_result_str = ''
                row_num = 0
                for row in range(1, 11):
                    x1 = 452 + row_num
                    y1 = 87
                    x2 = 472 + row_num
                    y2 = 107
                    column_num = 0  # 行
                    for column in range(1, 7):  # 列
                        Z_PIC = self.dm.FindPicE(x1, y1 + column_num, x2, y2 + column_num, "resource_pic/庄.bmp",
                                                 "080808",
                                                 0.4, 0)
                        X_PIC = self.dm.FindPicE(x1, y1 + column_num, x2, y2 + column_num, "resource_pic/闲.bmp",
                                                 "080808",
                                                 0.4, 0)
                        H_PIC = self.dm.FindPicE(x1, y1 + column_num, x2, y2 + column_num, "resource_pic/和.bmp",
                                                 "080808",
                                                 0.4, 0)
                        list_z = Z_PIC.split("|")
                        list_x = X_PIC.split("|")
                        list_h = H_PIC.split("|")
                        if int(list_z[1]) > 0:
                            self.one_result_str += '庄'
                        elif int(list_x[1]) > 0:
                            self.one_result_str += '闲'
                        elif int(list_h[1]) > 0:
                            self.one_result_str += '和'
                        else:
                            pass
                        column_num += 20
                    row_num += 20
                # 发送心跳|信号
                self.global_signals.data1_heart_signal.emit(self.data1_heart_count)
        except Exception as e:
            print('left_one_table出错--->', e)

    # 比对开奖结果
    def check_result(self, result_str):
        # 将开奖结果与等待方案进行比对
        for idx, (key, value) in enumerate(self.plan_dic.items()):
            # print(f'1号台.....循环比对方案中..........----->{key},{value}')
            if not result_str.endswith(value):
                # 识别第几个方案，调用对应方案线程
                print(f'1台---->{idx + 1}方案已出现，调用{idx + 1}模拟下注线程')
                # 用多线程执行自动下注
                if idx == 0:  # 方案1
                    print(f'1台-------->准备启用{idx + 1}方案自动下注！')
                    print(f'判断bet1线程是否被占用----->当前状态->{self.bet1.isRunning}')
                    if not self.bet1.isRunning:
                        time.sleep(0.1)  # 测试延迟
                        self.bet1.moveToThread(self.betting1Thread)
                        print('已将bet1移入线程')
                        time.sleep(0.1)  # 测试延迟
                        self.betting1Thread.start()
                        print('已开启bet1线程')
                        time.sleep(0.1)  # 测试延迟
                        self.bet1.start()
                        print('已开启bet1')
                        time.sleep(0.1)  # 测试延迟
                        # print(f'1台-------->{idx + 1}方案自动下注，启用完毕！')

                value = f'方案{idx + 1}---->' + value
                return value
        else:
            str = '暂无匹配方案'
            return str


# 10个方案对应的模拟下注
class Betting1(QThread):
    global_signals = GlobalSignals()
    def __init__(self, data_signal, data_fail_signal):
        super().__init__()
        # 调用大漠
        try:
            self.result_queue = Queue()  # 获取(赢,和)开奖数据|队列
            self.result_fail_queue = Queue()  # 获取(输)开奖数据|队列
            self.dm = win32com.client.Dispatch('dm.dmsoft')
            self.isRunning = False
            self.results = []  # 存储开奖结果
            self.num_list = [[100, 200, 400, 800], [110, 220, 440, 880], [120, 240, 480, 960], [130, 260, 520, 1040],
                             [140, 280, 560, 1120], [150, 300, 600, 1200], [160, 320, 640, 1280], [170, 340, 680, 1360],
                             [180, 360, 720, 1440], [190, 380, 760, 1520], [200, 400, 800, 1600], [220, 440, 880, 1720],
                             [240, 480, 960, 1920], [260, 520, 1040, 2080], [280, 560, 1120, 2240],
                             [300, 600, 1200, 2400],
                             [320, 640, 1280, 2560], [340, 680, 1360, 2720], [360, 720, 1440, 2880],
                             [380, 760, 1520, 3040],
                             [400, 800, 1600, 3200], [430, 860, 1720, 3440], [460, 920, 1840, 3680],
                             [490, 980, 1960, 3920],
                             [520, 1040, 2080, 4160], [550, 1100, 2200, 4400], [590, 1180, 2360, 4720],
                             [630, 1260, 2520, 5040],
                             [670, 1340, 2680, 5360], [710, 1420, 2840, 5680]]  # 下注计划金额
            self.bet_scheme = ['闲', '闲', '庄', '闲']  # 下注方案
            self.current_step = 0  # 当前下注步骤
            self.total_profit = 0  # 总盈利
            self.double_count = 0  # 倍投次数
            self.data_signal = data_signal  # 根据调用者，判断(赢,和)开奖信号源
            self.data_fail_signal = data_fail_signal  # 根据调用者，判断(输)开奖信号源
            self.first_in = True  # 首次下注
            self.fail_state = False  # 输状态
        except Exception as e:
            print(e)

    def run(self):
        try:
            # 调用 自动下注系统
            self.isRunning = True
            print('*' * 50)
            self.global_signals.bet1_log_signal.emit('已将bet1线程状态设定-->运行')
            # self.clear_queue(self.result_queue)
            # print('         已清空队列')
            time.sleep(0.1)  # 测试延迟
            self.data_signal.connect(self.get_data)  # 实时获取|(赢,和)开奖数据
            self.data_fail_signal.connect(self.get_fail_data)  # 实时获取|(输)开奖数据
            self.global_signals.bet1_log_signal.emit('已建立1台开奖信号连接')
            time.sleep(0.1)  # 测试延迟
            self.simulate_betting()  # 开启模拟下注
            self.global_signals.bet1_log_signal.emit('bet1下注结束')
            time.sleep(0.1)  # 测试延迟
            self.isRunning = False
            self.global_signals.bet1_log_signal.emit('已将bet1线程状态设定-->停止')
            self.current_step = 0  # 当前下注步骤
            self.first_in = True # 首次下注状态
            self.global_signals.bet1_log_signal.emit('已初始化|当前下注步骤|首次下注')
        except Exception as e:
            print('Betting1|run--->', e)

    # 模拟下注系统函数
    def simulate_betting(self):
        try:
            self.global_signals.bet1_log_signal.emit('----循环外----')
            while True:
                self.global_signals.bet1_log_signal.emit('----循环内----')
                # 递增下注计划
                self.global_signals.bet1_log_signal.emit(f'此时各项状态--->当前下注{self.current_step}|首次下注状态{self.first_in}|输状态{self.fail_state}')
                time.sleep(0.1)
                # 首次下注
                if self.first_in:  # 判断|是否首次下注
                    self.global_signals.bet1_log_signal.emit('自动下注系统----->首次下注')
                    if self.current_step == 0:
                        if self.double_count < 29:
                            # ---------------第一次下注-----------------
                            self.global_signals.bet1_log_signal.emit(
                                "下注<{}>={}元".format(self.bet_scheme[self.current_step],
                                                       self.num_list[self.double_count][
                                                           self.current_step]))
                            self.first_in = False  # 将非首次下注设置为假
                        else:
                            self.global_signals.bet1_log_signal.emit('已连挂30次，程序停止')
                            break
                        self.current_step = 1

                # ---------------等待开奖-----------------
                time.sleep(1)
                self.global_signals.bet1_log_signal.emit('自动下注系统---->第1次下注后判断是否开奖')
                if not self.result_queue.empty() or not self.result_fail_queue.empty():  # 判断是否开奖
                    if not self.fail_state:
                        result = self.result_queue.get()  # 获取(赢,和)最新开奖数据
                    else:
                        result = self.result_fail_queue.get() # 获取(输)最新开奖数据
                    # 处理下注步骤
                    if self.current_step > 0:
                        # ------------------------->和
                        if result == '和':
                            self.global_signals.bet1_log_signal.emit("当前开奖为'和', 继续下注当前金额<{}>={}元".format(
                                self.bet_scheme[self.current_step - 1],
                                self.num_list[self.double_count][
                                    self.current_step - 1]))
                            self.global_signals.bet1_log_signal.emit(f'当前总盈利{self.total_profit}元')
                            self.fail_state = False  # 关闭|输状态
                        # ------------------------->赢
                        elif result == self.bet_scheme[self.current_step - 1]:
                            self.total_profit += self.num_list[self.double_count][
                                self.current_step - 1]  # 结果赢，总盈利 + 当前下注金额
                            self.global_signals.bet1_log_signal.emit(
                                f"恭喜！赢了！！,盈利{self.num_list[self.double_count][self.current_step - 1]}元, 追加下注<{self.bet_scheme[self.current_step]}>金额:{self.num_list[self.double_count][self.current_step]}元")
                            self.current_step += 1
                            self.global_signals.bet1_log_signal.emit(f'当前总盈利{self.total_profit}元')
                            self.fail_state = False  # 关闭|输状态
                            # 如果4手计划成功
                            if self.current_step == 5:
                                if self.double_count < 29:
                                    self.global_signals.bet1_log_signal.emit(
                                        f'恭喜！4手连成！！盈利{self.num_list[self.double_count][self.current_step - 1]}元')
                                    self.global_signals.bet1_log_signal.emit(f'当前总盈利{self.total_profit}元')
                                    self.fail_state = False  # 关闭|输状态
                                    break
                                else:
                                    self.global_signals.bet1_log_signal.emit('已连挂30次，程序停止')
                                    self.fail_state = False  # 关闭|输状态
                                    break
                        else:
                            # ------------------------->输
                            self.total_profit -= self.num_list[self.double_count][
                                self.current_step - 1]  # 结果输，总盈利 - 当前下注金额
                            self.global_signals.bet1_log_signal.emit(
                                f'很遗憾！输了！！亏损{self.num_list[self.double_count][self.current_step - 1]}元, 等待方案1再次出现')
                            self.global_signals.bet1_log_signal.emit(f'         当前总盈利{self.total_profit}元')
                            self.double_count += 1  # 递增下注计划
                            self.current_step = 0   # 重置|下注步骤
                            self.first_in = True    # 重置|首次下注
                            self.fail_state = True  # 开启|输状态
                            break
                    self.global_signals.bet1_log_signal.emit('----------无限循环停止了2----------')
            self.global_signals.bet1_log_signal.emit('----------无限循环停止了1----------')
        except Exception as e:
            print('simulate_betting--->', e)

    # (赢,和)|开奖数据获取
    def get_data(self, value):
        try:
            if not self.fail_state:  # 判断输是否为假
                self.global_signals.bet1_log_signal.emit(f'方案1已获取到(赢,和)开奖结果，已加入队列---->{value[-1]}')
                self.result_queue.put(value[-1])
            else:
                self.global_signals.bet1_log_signal.emit('当前为(输)状态，不接收(赢,和)开奖数据')
        except Exception as e:
            print('get_data--->', e)

    # (输)|开奖数据获取
    def get_fail_data(self, fail_value):
        try:
            if self.fail_state:  # 判断输是否为真
                self.global_signals.bet1_log_signal.emit(f'方案1已获取到(输)开奖结果，已加入队列---->{fail_value[-1]}')
                self.result_fail_queue.put(fail_value[-1])
            else:
                self.global_signals.bet1_log_signal.emit('当前为(赢,和)状态，不接收(输)开奖数据')
        except Exception as e:
            print('get_fail_data--->', e)


# UI界面
class BaiJiaLe(QMainWindow, Ui_mainwindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        # 调用大漠
        self.dm = win32com.client.Dispatch('dm.dmsoft')
        # 绑定|映射信号

        Betting1.global_signals.bet1_log_signal.connect(self.one_bet1_log)
        Worker1.global_signals.data1_ui_signal.connect(self.one_updateProgram)
        Worker1.global_signals.data1_stop_signal.connect(self.one_updateProgram)
        Worker1.global_signals.data1_check_signal.connect(self.one_check_result)
        Worker1.global_signals.data1_heart_signal.connect(self.one_heart_count)

    # 多线程任务
    def taskstart(self):
        try:
            # 实例化|多线程
            self.work1 = Worker1(self.dm)
            # 开启线程
            self.work1.start()
        except Exception as e:
            print('taskstart出错--->', e)

    # 1台 开奖数据|开奖数量|更新
    def one_updateProgram(self, data):
        try:
            self.one_table_label.setText(data)
            self.one_current_count_lable.setText(str(len(data)))
        except Exception as e:
            print('one_updateProgram--->', e)

    # 1台 检查结果|更新
    def one_check_result(self, data):
        try:
            self.one_check_result_lable.setText(data)
        except Exception as e:
            print('one_check_result--->', e)

    # 1台 心跳|更新
    def one_heart_count(self, data):
        try:
            self.one_hear_count_lable.setText(str(data))
        except Exception as e:
            print('one_heart_count--->', e)

    # 方案1 自动下注|日志|更新
    def one_bet1_log(self, data):
        try:
            self.one_bet1_edi.append(data)
        except Exception as e:
            print('one_bet1_log--->', e)

    # 绑定窗口
    def bind_window(self):
        # 绑定窗口
        hwnd = self.bind_id_edi.text()  # 窗口句柄ID
        dm_ret = self.dm.BindWindow(hwnd, "dx2", "windows", "windows", 1)
        if dm_ret == 1:
            print('绑定成功')
        else:
            print('绑定失败')


if __name__ == '__main__':
    import sys

    app = QApplication(sys.argv)
    window = BaiJiaLe()
    window.show()
    sys.exit(app.exec_())
